
# CRM Contacts Distribution Service

Асинхронный сервис на FastAPI для приёма обращений (contacts) от разных источников (ботов/каналов) и распределения этих обращений по операторам с учётом весов и лимитов нагрузки.  
Сервис хранит лидов, операторов, источники, конфигурации распределения и историю обращений.

---

## Стек и технологии

- **Python 3.11**
- **FastAPI** + Starlette middleware
- **SQLAlchemy 2.x (async)** + AsyncSession
- **Alembic** для миграций
- БД: **SQLite**
- **Docker / Docker Compose**
- Тесты: **pytest**, **pytest-asyncio**

---

## Что реализовано

- CRUD для **операторов** (создание, список).
- CRUD для **источников** (создание, список).
- Настройка конфигурации распределения операторов по источнику (веса).
- Приём обращения `/contacts`:
  - поиск/создание лида,
  - выбор оператора по алгоритму распределения,
  - создание контакта (обращения) с привязкой к лиду, источнику и оператору (или без оператора).
- Получение списка лидов с их обращениями.
- Асинхронная архитектура: репозитории, сервисы, DI.
- Интеграционные тесты API.

---

## Модель данных

Сущности:

1. **Lead** — клиент/потенциальный клиент.
   - поля: `id`, `external_id` (уникальный внешний идентификатор), `phone`, `email`, `created_at`
   - связи: `Lead 1—N Contact`

2. **Source** — источник обращений (бот, канал, интеграция).
   - поля: `id`, `code` (уникальный код), `name`, `created_at`
   - связи:
     - `Source 1—N Contact`
     - `Source 1—N SourceOperatorConfig`

3. **Operator** — оператор, который обрабатывает обращения.
   - поля: `id`, `name`, `is_active`, `max_active_contacts`, `created_at`
   - связи:
     - `Operator 1—N Contact`
     - `Operator 1—N SourceOperatorConfig`

4. **SourceOperatorConfig** — конфигурация распределения операторов в рамках конкретного источника.
   - поля: `id`, `source_id`, `operator_id`, `weight`
   - ограничения: уникальная пара (`source_id`, `operator_id`)
   - смысл: определяет, какой оператор участвует в распределении от данного источника и с каким весом.
   - связи: `Source N—M Operator` через таблицу конфигураций.

5. **Contact** — обращение от лида.
   - поля: `id`, `lead_id`, `source_id`, `operator_id (nullable)`, `payload`, `status`, `created_at`
   - `operator_id` может быть `NULL`, если распределить некуда.

---

## Алгоритм распределения обращений

### 1) Как определяется, что обращения принадлежат одному и тому же лиду
- В запросе на создание контакта приходит `lead.external_id`.
- Если в БД уже есть **Lead** с таким `external_id`, обращение привязывается к нему.
- Если лида нет — создаётся новый `Lead` с этим `external_id`, плюс сохраняются `phone/email` (если переданы).

Таким образом, **external_id является ключом склейки лидов**.

---

### 2) Как учитываются веса операторов по источникам
- Для каждого источника хранится набор конфигураций **SourceOperatorConfig**:
  - `source_id`
  - `operator_id`
  - `weight`
- При выборе оператора сервис:
  1. Берёт все конфиги для данного `source_id`.
  2. Оставляет только операторов с `weight > 0` и `is_active=True`.
  3. Делает **weighted random choice** (`random.choices`) по весам:
     - чем больше вес — тем выше вероятность выбора.

---

### 3) Как учитываются лимиты нагрузки
- У оператора есть `max_active_contacts`.
- Нагрузка считается как количество активных обращений:
  - `active_cnt = count(Contact where operator_id=... and status='active')`
- Оператор участвует в выборе только если:
  - `active_cnt < max_active_contacts`
- После предварительного выбора делается повторная проверка (защита от гонок):
  - если лимит достигнут, выбирается другой кандидат по весам.

---

### 4) Что происходит, если подходящих операторов нет
Подходящих операторов может не быть если:
- нет конфигурации для источника,
- все операторы неактивны,
- веса равны 0,
- или все упёрлись в лимиты нагрузки.

Тогда:
- `choose_operator()` возвращает `None`,
- создаётся **Contact** с `operator_id = NULL`,
- обращение остаётся нераспределённым.

---

## Запуск проекта

### 1) Локально (без Docker)

1. Создать виртуальное окружение и поставить зависимости:
   ```bash
   python -m venv venv
   source venv/bin/activate
   pip install -r requirements.txt


2. Применить миграции:

   ```bash
   alembic upgrade head
   ```

3. Запустить приложение:

   ```bash
   uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
   ```

4. Swagger будет доступен:

   ```
   http://localhost:8000/docs
   ```

---

### 2) Запуск через Docker Compose

1. Собрать и поднять контейнеры:

   ```bash
   docker compose up --build
   ```

2. Приложение доступно на:

   ```
   http://localhost:8000/docs
   ```

---

## Запуск тестов

### Внутри контейнера

Если ты уже внутри контейнера:

```bash
pytest -q
```

### Через docker compose

Из корня проекта:

```bash
docker compose run --rm api pytest -q
```

---

## Основные эндпоинты

* `POST /api/v1/operators` — создать оператора
* `GET  /api/v1/operators` — список операторов
* `POST /api/v1/sources` — создать источник
* `GET  /api/v1/sources` — список источников
* `PUT  /api/v1/sources/{id}/operators` — задать веса операторов для источника
* `POST /api/v1/contacts` — зарегистрировать обращение (распределяется автоматически)
* `GET  /api/v1/leads` — список лидов + их обращения

---

## Пример сценария

1. Создать операторов.
2. Создать источник (бот).
3. Прописать конфигурацию операторов и весов для источника.
4. Отправлять `POST /contacts` — сервис сам:

   * найдёт/создаст лида,
   * выберет оператора с учётом весов и лимитов,
   * создаст обращение.
